<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://mattiaracca.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://mattiaracca.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-18T20:06:43+00:00</updated><id>https://mattiaracca.github.io/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">Dotfiles and stow 📥</title><link href="https://mattiaracca.github.io/blog/2025/dotfiles/" rel="alternate" type="text/html" title="Dotfiles and stow 📥"/><published>2025-09-17T21:00:00+00:00</published><updated>2025-09-17T21:00:00+00:00</updated><id>https://mattiaracca.github.io/blog/2025/dotfiles</id><content type="html" xml:base="https://mattiaracca.github.io/blog/2025/dotfiles/"><![CDATA[<blockquote class="block-tip"> <p>This post is 100% GenAI-free. Read <a href="/blog/2025/experiment/">here</a> why.</p> </blockquote> <p>There are many things I did not get right when I started doing research – back in <del>my days</del> 2015, when the ROS distro was Indigo, Python was at 2.7 but the default choice for robotics was mediocre C++ code or, worse, Matlab scripts. There are still many things that I do not get right today, but that’s a wider topic.</p> <p>There is however one habit I picked up from a Linux savvy friend fairly early in my career (beginning of 2018, looking at the git history) that I think helped me streamline something that I find incredible tedious: setting up a pc after a fresh Linux install.</p> <p><strong>tl;dr</strong>, I have a Github repo <a href="https://github.com/mattiaracca/dotfiles"><code class="language-plaintext highlighter-rouge">dotfiles</code></a> containing</p> <ul> <li>dotfiles (duh) (<code class="language-plaintext highlighter-rouge">.bashrc</code>, <code class="language-plaintext highlighter-rouge">.vimrc</code>, <code class="language-plaintext highlighter-rouge">.bash_aliases</code> and so on)</li> <li>an installation script <code class="language-plaintext highlighter-rouge">setup.sh</code> that I keep updated as my needs change and Ubuntu versioning advances.</li> </ul> <p>On a fresh install,</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/mattiaracca/dotfiles
<span class="nb">source </span>dotfiles/setup.sh
</code></pre></div></div> <p>and… I have <strong>my machine</strong> back.</p> <blockquote class="block-warning"> <p>Disclaimer: Depending on your background, what I just described may be… the norm. If that’s the case, this post is not for you, I’m afraid. It’s for robotics researchers who, by nature of the field, come from disparate backgrounds: computer science, computer/mechanical/electrical engineering… and psychology, social sciences, and design if you look at the Human-Robot Interaction community.</p> </blockquote> <h2 id="why-versioning-dotfiles">Why versioning dotfiles</h2> <p>First, what are dotfiles? Brutally copy-pasted from <a href="https://www.datacamp.com/tutorial/dotfiles">this blog post</a></p> <blockquote> <p>Dotfiles are hidden configuration files on a Unix-based system that are hidden by default due to their unique prefix (.). These files store configurations, settings, and preferences for applications and tools, such as version control systems and editors. They make it easy for developers to create customized environments personalized to their workflows.</p> </blockquote> <p>Your <code class="language-plaintext highlighter-rouge">.bashrc</code> is a dotfile. The <code class="language-plaintext highlighter-rouge">.config</code> folder in your home is a standard place where applications expect dotfiles.</p> <p>Why a dotfiles repo? Because having all my dotfiles in one place let’s me</p> <ol> <li>avoid remembering or googling stuff like <em>does this dotfile go in <code class="language-plaintext highlighter-rouge">.config/</code> or directly in <code class="language-plaintext highlighter-rouge">~/</code>?</em> or <em>how to install zotero/zoom/dropbox/ros/texlive?</em>.</li> <li>have a growing library of custom commands and settings that I can just <code class="language-plaintext highlighter-rouge">git clone</code></li> </ol> <p>It does make it hard for me to work on vanilla machines (<em>e.g.</em> computers of colleagues) because I don’t have my commands/aliases. But then again, that’s a pretty rare occasion.</p> <p>Versioning dotfiles is not really arcane magic. What really does it for me is the use of <code class="language-plaintext highlighter-rouge">stow</code> and having a <code class="language-plaintext highlighter-rouge">setup.sh</code>.</p> <h2 id="using-stow-to-handle-dotfiles">Using stow to handle dotfiles</h2> <p>The idea comes from <a href="https://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html">here</a> and I’ll never be grateful enough. In short, you use the command <code class="language-plaintext highlighter-rouge">stow</code> to symlink your dotfiles (now neatly versioned in your <code class="language-plaintext highlighter-rouge">dotfiles</code> repo) where they are needed.</p> <p>Let’s say I want the versioned ssh <code class="language-plaintext highlighter-rouge">config</code> file to go where it usually sits at <code class="language-plaintext highlighter-rouge">~/.ssh/config</code>. In the repo root, I create a <code class="language-plaintext highlighter-rouge">ssh</code> folder, with inside the same folder structure of <code class="language-plaintext highlighter-rouge">~/.ssh/config</code> (so a folder called <code class="language-plaintext highlighter-rouge">.ssh</code> with inside the <code class="language-plaintext highlighter-rouge">config</code> file).</p> <p>From the repo root, I then <code class="language-plaintext highlighter-rouge">stow ssh</code> and now the <code class="language-plaintext highlighter-rouge">config</code> is correctly symlinked where needed. If you make changes inside the dotfiles folder, they are immediately applied (it’s a symlink). If you or something changes them in <code class="language-plaintext highlighter-rouge">~/.ssh/config</code>, you’ll see it with <code class="language-plaintext highlighter-rouge">git status</code>, ready to be committed (or discarded).</p> <p>Another example: <code class="language-plaintext highlighter-rouge">.vimrc</code> sits in <code class="language-plaintext highlighter-rouge">~/</code>. In the repo, create a <code class="language-plaintext highlighter-rouge">vim</code> folder, put inside your <code class="language-plaintext highlighter-rouge">.vimrc</code>, <code class="language-plaintext highlighter-rouge">stow vim</code>, done.</p> <p>This is what the <code class="language-plaintext highlighter-rouge">tree</code> command would give you from the root of the repo</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotfiles
├── ssh
│   └── .ssh
│       └── config
└── vim
    └── .vimrc

</code></pre></div></div> <h3 id="machine-specific-dotfiles">Machine specific dotfiles</h3> <p>What if I have many machines and some settings are wrong/nonsensical/unnecessary for some machine?</p> <p>In that case, what works for me is to create machine specific scripts like <code class="language-plaintext highlighter-rouge">mylaptop.sh</code> and then have this at the end of my <code class="language-plaintext highlighter-rouge">.bashrc</code></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> ~/dotfiles/host_specific/<span class="nv">$HOSTNAME</span>.sh <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">source</span> ~/dotfiles/host_specific/<span class="nv">$HOSTNAME</span>.sh
<span class="k">fi</span>
</code></pre></div></div> <p>Like that, I have machine-specific commands, env variables, and the like.</p> <h2 id="the-setupsh">The <code class="language-plaintext highlighter-rouge">setup.sh</code></h2> <p>The setup script builds on all of the above and provides an entrypoint on a fresh install. These are excerpts of <a href="https://github.com/MattiaRacca/dotfiles/blob/master/setup.sh">mine</a>, just to give you an idea of what I mean</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">===== Fresh installation =====</span><span class="se">\n</span><span class="s2">"</span>
<span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>stow

<span class="nb">read</span> <span class="nt">-p</span> <span class="s1">'stow bash files? [y/n]: '</span> answer
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"y"</span> <span class="nt">-o</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span><span class="k">then
  </span><span class="nb">rm</span> ~/.bashrc
  <span class="nb">rm</span> ~/.bash_logout
  stow bash
<span class="k">fi

</span><span class="nb">read</span> <span class="nt">-p</span> <span class="s1">'Do you want vim? [y/n]: '</span> answer
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"y"</span> <span class="nt">-o</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span><span class="k">then
  </span><span class="nb">sudo </span>apt <span class="nb">install </span>vim
  stow vim
<span class="k">fi</span>
</code></pre></div></div> <p>It’s not just stowing. The script does things I always forget how to do, like, <em>e.g.</em> create a ssh key</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">read</span> <span class="nt">-p</span> <span class="s1">'Create SSH key? [y/n]: '</span> answer
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"y"</span> <span class="nt">-o</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span><span class="k">then
  </span>ssh-keygen <span class="nt">-t</span> ed25519 <span class="nt">-C</span> <span class="s2">"definitively@not_my.email"</span> <span class="nt">-f</span> ~/.ssh/id_ed25519
  ssh-add ~/.ssh/id_ed25519
<span class="k">fi</span>
</code></pre></div></div> <p>or install things that require more than a simple <code class="language-plaintext highlighter-rouge">apt install</code>, like <em>e.g.</em> zoom</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">read</span> <span class="nt">-p</span> <span class="s1">'Do you want Zoom? [y/n]: '</span> answer
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"y"</span> <span class="nt">-o</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$answer</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span><span class="k">then
  </span>wget <span class="nt">-O</span> /tmp/zoom.deb https://zoom.us/client/latest/zoom_amd64.deb
  <span class="nb">sudo </span>apt <span class="nt">-f</span> <span class="nb">install</span> /tmp/zoom.deb
  <span class="o">(</span>crontab <span class="nt">-l</span> <span class="p">;</span> <span class="nb">echo</span> <span class="s2">"@reboot nohup setsid zoom"</span><span class="o">)</span>| crontab -
<span class="k">fi</span>
</code></pre></div></div> <p>The “secret” here is maintaining the script over time, adding new procedures to it (better when you are doing a procedure manually for the first time), removing stuff that became irrelevant or obsolete, etc.</p> <p>I cannot estimate how much time this saved me (also because maintaining the repo does take some time every now and then). It sure improved my “Linux Hygiene” and made my actual work (doing research) much smoother.</p>]]></content><author><name>Mattia Racca</name></author><category term="cs"/><category term="linux"/><category term="programming"/><summary type="html"><![CDATA[Why having dotfiles version-controlled and stow-ed saved me from a ton of tedious work.]]></summary></entry><entry><title type="html">A writing experiment</title><link href="https://mattiaracca.github.io/blog/2025/experiment/" rel="alternate" type="text/html" title="A writing experiment"/><published>2025-09-09T21:00:00+00:00</published><updated>2025-09-09T21:00:00+00:00</updated><id>https://mattiaracca.github.io/blog/2025/experiment</id><content type="html" xml:base="https://mattiaracca.github.io/blog/2025/experiment/"><![CDATA[<p>This is an experiment: I want to do some writing that is not strictly academic (conference papers, reviews, quarterly reports) for several reasons, personal and professional. Chiefly, I worry about the increasingly available shortcuts provided by LLMs for writing tasks.</p> <p>Look, people that know me are well aware that I’m not a fan of ChatGPT and the like. As much as disliking <a href="https://xkcd.com/1838/">a big pile of linear algebra</a> that is incredibly good at predicting next tokens is nonsensical (and funny), there is no shortage of things around LLMs that I can take issue with: the energy footprint of the latest models, the indiscriminate stealing of art for training, the perpetuation of racial biases harvested from the internet, or the whole snake oil marketing operation.</p> <p>Yet, if I zoom-in and take an egoistic view at the problem for a moment, my main issue is about <strong>how easy is to use such tools</strong> and, consequently, <strong>how exposed we are to their shortcomings and dangers.</strong></p> <div class="row justify-content-center"> <div class="col-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="https://imgs.xkcd.com/comics/machine_learning-480.webp 480w,https://imgs.xkcd.com/comics/machine_learning-800.webp 800w,https://imgs.xkcd.com/comics/machine_learning-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="https://imgs.xkcd.com/comics/machine_learning.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Mandatory xkcd reference </div> <p>People wrote extensively on the topic (<em>e.g.</em> the <a href="https://dl.acm.org/doi/10.1145/3442188.3445922">Stochastic Parrots 🦜</a> paper), no need to survey the literature here. What I find worrying about such tools in my day-to-day life is</p> <ul> <li><strong>LLMs make content uniform.</strong> Things may look nice, but they look all so similar. LinkedIn posts (full of em dashes, strategically placed emoji, and cringe comic strips) are the epitome of this flattening process. You can’t unsee the <a href="https://knowyourmeme.com/memes/ai-art-becoming-yellow">Piss Filter</a> of recent GenAI images. Every paper is now <a href="https://arxiv.org/abs/2406.07016">delving into crucial issues</a>. <strong>No thanks, I value originality over presentation.</strong></li> <li><strong>LLMs make me lazy and complacent.</strong> Why should I write that <code class="language-plaintext highlighter-rouge">bash</code> script when Copilot can wing it for me in seconds? and why should I then revise/understand it before running it? and, if it sort-of works, why should I try to improve it or clean it? <strong>No thanks, I’m not ready to give up that much agency.</strong></li> <li><strong>LLMs shift my role from creator to reviewer.</strong> I want to make things, but I end up in a vicious cycle of revising what the LLM produced, begging it to make it right, revising and begging, rinse and repeat. <strong>No thanks, I’m not a <del>LLM-sitter</del> <del>Transformer supplicant</del> prompt engineer.</strong></li> </ul> <p>In short (and with a PKD quote, of all things), I’m asking myself</p> <blockquote> <p><em>[…] don’t you feel ashamed of yourself when you let a machine tell you what to do?</em></p> <p>– <a href="https://www.goodreads.com/book/show/22595.Vulcan_s_Hammer">Philip K. Dick, Vulcan’s Hammer</a></p> </blockquote> <h3 id="so-whats-with-this-experiment">So what’s with this experiment?</h3> <p>I’m gonna write some blog posts about things I’m interested in, without any GenAI assistance (except for a good ol’ dictionary-based spell checker, because I’m not a native speaker of English). <em>Maybe</em>, this will make me feel more creative, more focused (and less prone to unproductive multitasking), and help me regain some agency at my own pace.</p>]]></content><author><name>Mattia Racca</name></author><category term="writing"/><category term="research"/><category term="hobbies"/><summary type="html"><![CDATA[Blog posts? in this LLM economy?!]]></summary></entry></feed>